Furious Five — Tech Stack & Implementation Details (no roadmap)
1) Architecture (single-machine, LAN-playable)

Monorepo: pnpm workspaces.

packages/types – shared TypeScript types & Zod schemas.

packages/engine – pure game engine (rules, reducer, invariants, settlement).

apps/server – Node.js (Express + Socket.IO). Holds authoritative game state in memory.

apps/web – Vite + React + TypeScript client. Connects to server via WebSocket.

Why this stack

Socket.IO keeps LAN setup trivial (no STUN/TURN).

Pure engine library gives determinism, testability, and reuse (server-validated, client-preview).

No DB: all state in RAM; rounds are quick and ephemeral.

2) Runtime & libraries

Language: TypeScript everywhere, strict mode.

Server: Node 20+, Express (serves static build or CORS for Vite dev), Socket.IO, Zod (runtime validation).

Client: React 18, Vite, Tailwind (fast styling), socket.io-client.

Testing: Vitest for unit/property tests inside packages/engine.

Build: Vite for web, tsc for packages/server.

3) Data model (shared)
// Cards
type Suit = 'C'|'D'|'H'|'S';
type Rank = 1|2|...|13;         // A=1, ..., K=13
type Card = { r: Rank; s: Suit };

// Drops
type DropKind = 'single'|'pair'|'trips'|'quads'|'straight';
type Drop = { kind: DropKind; cards: Card[] };

// Players & game
type Player = { id: string; name: string; connected: boolean; hand: Card[]; chipDelta: number };
type TableDrop = { kind: DropKind; cards: Card[] } | null;
type Phase = 'lobby'|'playing'|'settlement';
type TurnStage = 'start'|'dropped'|'end'; // enforces order: CALL -> DROP -> DRAW

type GameState = {
  roomCode: string;
  phase: Phase;
  players: Player[];
  turnIdx: number;          // whose turn (index into players[])
  turnStage: TurnStage;     // where in the turn sequence
  deck: Card[];
  graveyard: Card[];        // only for reshuffles
  tableDrop: TableDrop;     // the one live pile you can draw from
  settlement?: { callerIdx: number; totals: number[]; payouts: number[] } | null;
};

Invariants (checked on every reducer step in dev/builds)

Card conservation: sum(lengths of all hands) + deck.length + graveyard.length + (tableDrop?.cards.length||0) == 52.

Uniqueness: every Card appears once globally.

Turn legality: only players[turnIdx] can act; turnStage sequencing: start → dropped → end(start).

Hand size: end-of-turn hand size ∈ [1,5].

Table rules: if tableDrop.kind==='straight' then cards.length>=3. If straight shrinks to 2, treat as non-straight for picking.

4) Engine (pure, deterministic)

Determinism: All randomness (shuffles) provided as an input (pre-shuffled deck or seeded RNG), never generated inside reducers.

Core helpers:

isSameRank(cards, n), isStraight(cards) (A low only, length ≥3), sumPoints(hand), removeCards(hand, cards) (by value).

Validators (pure):

validateDrop(hand, drop) → boolean.

canCall(state, playerId) → boolean (only at turnStage==='start' and sumPoints<5).

canDrawFromTable(tableDrop, pick) → boolean (ends for straight; any index otherwise).

Reducers (pure, no side effects):

startRound(state, rng?) – deal 5 each, reset piles, set turnStage='start'.

applyDrop(state, playerId, drop) – requires turnStage='start'; moves previous tableDrop → graveyard; sets new tableDrop; sets turnStage='dropped'.

drawFromDeck(state, playerId) – only after drop; reshuffle graveyard into deck if needed (tableDrop remains); push drawn card; advanceTurn().

drawFromTable(state, playerId, pick) – take low/high for straight; specific index otherwise; if straight shrinks to 2, mark as non-straight for future picking; advanceTurn().

settleOnCall(state, playerId) – only at turnStage='start'; compute totals, identify lowest, apply success/failed caller rules and tie-break, update chipDelta, switch to phase='settlement'.

Tie-break (failed call)

If multiple non-caller players tie for lowest, choose receiver by clockwise order from the caller (deterministic, single payee).

5) Server (authoritative orchestration)

Connection: Socket.IO namespace per app (default is fine). One room per game (roomCode as Socket.IO room).

Room manager: Map<roomCode, GameState>. Optionally track lastActivityAt for idle GC.

Identity: socket.id as Player.id. Names provided by client; server trims/sanitizes.

Event contract (Zod-validated)

C2S: room:create, room:join, game:start, turn:call, turn:drop, turn:drawDeck, turn:drawFromTable, round:new.

S2C: state:update, error.

Flow: On each C2S:

Validate payload (Zod) & turn ownership.

Run engine function (pure) to derive nextState.

Store state and broadcast state:update to the room.

Authoritative checks: server ignores illegal moves (and emits error with a code, e.g., E_TURN, E_ILLEGAL_DROP, E_CALL_DENIED).

Reconnection: On connection, mark player.connected=true if found; on disconnect, mark false. State persists in memory until server exits.

Static hosting (optional): In production, Express can serve the built client, so guests only hit http://<host-ip>:8080.

Security & anti-cheat (within LAN)

Server never trusts client-side legality; engine validation is the source of truth.

Every transition re-validates card conservation and uniqueness (dev assert). If violated, server refuses transition and logs diagnostic.

6) Client (React UI, thin logic)

Connection: socket.io-client to ws://<host-ip>:8080. Reconnect with backoff.

State: The server’s GameState is the single source of truth. Client keeps only ephemeral UI selections (e.g., which cards are highlighted).

Components:

Lobby: show roomCode, players; “Start Game” (visible for all; server doesn’t gate by role in MVP).

TableDrop: render live pile; if straight and it’s your turn and turnStage==='dropped', show Take Low/High buttons; else show Take #i buttons.

Hand: render cards; click to select; show “Drop {kind}” if current selection forms a valid set/straight (client can preview with the same helper logic as engine, but server still validates).

Controls: “Call” (enabled only when turnStage==='start' and it’s your turn; server will still reject if total ≥5). “Draw from Deck” after a drop.

Settlement: list totals, payouts, and running chipDelta.

UX correctness guards:

Disable buttons when it’s not the player’s turn or the turnStage is wrong.

Visual hints (e.g., highlight valid straight ends).

7) Networking protocol details

Message ordering: Rely on Socket.IO ordering (per-connection FIFO). Server also enforces turn locks using turnIdx.

Idempotency: If a client resends the same action (e.g., network hiccup), it will fail validation because state moved on; server responds with a benign error.

Versioning: Include state.version (monotonic int) if you want clients to ignore out-of-date echoes; not required for MVP.

Error surface: Uniform {code, message} structure; UI shows toasts.

8) RNG & fairness

Shuffle: Fisher–Yates on a canonical ordered deck.

Seed (optional): For reproducible debugging, accept a seed; store it in room (dev only).

Engine purity: The reducer never calls Math.random; shuffles happen once, at startRound.

9) Rules encoding highlights

Call timing: canCall(state, playerId) returns true only when playerId===players[turnIdx].id && turnStage==='start' && sumPoints(hand)<5.

Drop-before-draw enforced: applyDrop transitions turnStage: 'start' → 'dropped'. Draw handlers require 'dropped'.

Table straight nibble: When straight length becomes 2 after a draw-from-table, set tableDrop.kind to a non-straight kind (e.g., 'pair' label for “small pile”) so next pick can be either card.

Reshuffle: Triggered only when drawing and deck.length===0; graveyard is shuffled into deck; tableDrop remains untouched.

10) Settlement mechanics (server-side)

Compute totals[i]=sumPoints(players[i].hand).

Find lowest among non-caller if caller fails (tie or strictly higher).

Success: each payouts[i] -= (totals[i]-totals[caller]) for i≠caller; caller receives the sum.

Fail: caller pays a single lowest player the sum Σ_{j≠lowest} (totals[j]-totals[lowest]). If multiple lowest, choose receiver by clockwise from caller.

Persist running ledger: players[i].chipDelta += payouts[i].

11) Testing strategy (engine-focused)

Unit tests:

validateDrop for all combos, including invalid straights and Ace wrap disallow.

Turn order & turnStage sequencing.

Draw-from-table rules (ends-only for straight; any-index for others).

Reshuffle integrity (card conservation after multiple cycles).

Settlement success/fail with ties and clockwise tie-break.

Property tests (light): random deals → random legal moves → assert invariants hold.

12) Operational details (local/LAN)

Ports: server :8080 (WebSocket + static build); dev client :5173.

CORS: if running dev client separately, allow http://<host-ip>:5173.

Env: client uses VITE_SOCKET_URL=ws://<host-ip>:8080.

Single-process hosting: In production, build web and serve via Express static → players visit http://<host-ip>:8080.

13) Observability & robustness (MVP-grade)

Structured logs: On server: log roomCode, event, playerId, and state deltas (size-only) for moves; log rejects with code.

Panic guards: If any invariant fails, reject the move and emit E_STATE_INVARIANT; keep previous state.

Rejoin: On reconnect, server re-broadcasts state:update so the client can repaint.

No persistence: A server restart wipes rooms (good enough for LAN MVP).